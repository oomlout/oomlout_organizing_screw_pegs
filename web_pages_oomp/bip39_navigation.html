{% extends "_layout.html" %}

{% block content %}
<section class="info-card">
  <h2>BIP-39 Word Navigation</h2>
  <p>
    Start typing the BIP-39 mnemonic words. Each box accepts plain text; results update on every
    keystroke, showing up to 200 matches.
  </p>
  <div class="form-field word-row">
    <div class="bip-input-wrap">
      <label class="sr-only" for="bip-word-1">BIP-39 word 1</label>
      <input id="bip-word-1" class="bip-word-input" type="search" placeholder="word 1" autocomplete="off" />
      <ul class="bip-suggestions" data-index="0"></ul>
    </div>
    <div class="bip-input-wrap">
      <label class="sr-only" for="bip-word-2">BIP-39 word 2</label>
      <input id="bip-word-2" class="bip-word-input" type="search" placeholder="word 2" autocomplete="off" />
      <ul class="bip-suggestions" data-index="1"></ul>
    </div>
    <div class="bip-input-wrap">
      <label class="sr-only" for="bip-word-3">BIP-39 word 3</label>
      <input id="bip-word-3" class="bip-word-input" type="search" placeholder="word 3 (filters list)" autocomplete="off" />
      <ul class="bip-suggestions" data-index="2"></ul>
    </div>
  </div>
</section>

<section class="info-card">
  <h3>Matching Parts</h3>
  <p id="bip-word-summary">
    Loading BIP-39 parts (up to 200 at a time). Enter mnemonic words to narrow the list.
  </p>
  <ul id="bip-word-results" class="part-filter-list"></ul>
</section>

<style>
  .word-row {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 0.75rem;
    align-items: flex-start;
  }

  .bip-input-wrap {
    position: relative;
  }

  .bip-word-input {
    width: 100%;
    font: inherit;
    padding: 0.7rem 0.85rem;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--bg-panel);
    color: var(--text-primary);
    box-shadow: var(--shadow-panel);
  }

  .bip-word-input:focus {
    outline: 2px solid rgba(37, 99, 235, 0.18);
    border-color: var(--accent);
  }

  .bip-suggestions {
    position: absolute;
    top: calc(100% + 0.3rem);
    left: 0;
    right: 0;
    margin: 0;
    padding: 0.4rem 0;
    list-style: none;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    box-shadow: var(--shadow-panel);
    max-height: 220px;
    overflow-y: auto;
    display: none;
    z-index: 10;
  }

  .bip-suggestions.show {
    display: block;
  }

  .bip-suggestions li {
    padding: 0.4rem 0.9rem;
    cursor: pointer;
  }

  .bip-suggestions li:hover {
    background: rgba(37, 99, 235, 0.08);
  }

  .bip-suggestions li.is-highlighted {
    background: var(--accent);
    color: #fff;
  }

  .part-filter-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 0.75rem;
  }

  .part-filter-item {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    box-shadow: var(--shadow-panel);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .part-filter-item:hover {
    border-color: var(--accent);
    box-shadow: 0 12px 24px -18px rgba(37, 99, 235, 0.45);
  }

  .part-filter-item a {
    display: grid;
    gap: 0.3rem;
    font-weight: 600;
    color: var(--text-primary);
    text-decoration: none;
    padding: 0.75rem 1rem;
  }

  .part-filter-id {
    font-weight: 650;
    font-size: 0.95rem;
    line-height: 1.3;
  }

  .part-filter-meta {
    font-size: 0.8rem;
    color: var(--text-muted);
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<script>
  (function () {
    const entries = {{ bip39_entries | tojson }};
    const normalized = entries.map((entry) => ({
      ...entry,
      lowerWords: entry.words.map((word) => String(word).toLowerCase()),
    }));
    const WORDS = {{ bip39_words | tojson }};
    const inputs = [
      document.getElementById("bip-word-1"),
      document.getElementById("bip-word-2"),
      document.getElementById("bip-word-3"),
    ];
    const suggestionLists = Array.from(document.querySelectorAll(".bip-suggestions"));
    const summary = document.getElementById("bip-word-summary");
    const list = document.getElementById("bip-word-results");
    const LIMIT = 200;
    const totalParts = normalized.length;
    const activeSuggestionIndex = [-1, -1, -1];

    function highlightSuggestion(listEl, index) {
      const items = listEl.querySelectorAll("li");
      items.forEach((item, idx) => {
        item.classList.toggle("is-highlighted", idx === index);
      });
    }

    function renderMatches(matches) {
      list.textContent = "";
      const fragment = document.createDocumentFragment();
      matches.forEach((entry) => {
        const li = document.createElement("li");
        li.className = "part-filter-item";

        const link = document.createElement("a");
        link.href = entry.detail_url;

        const idSpan = document.createElement("span");
        idSpan.className = "part-filter-id";
        idSpan.textContent = entry.id;

        const metaSpan = document.createElement("span");
        metaSpan.className = "part-filter-meta";
        metaSpan.textContent = `${entry.group} · ${entry.top_category || "unspecified"} · BIP-39: ${entry.words.join(" ")}`;

        link.appendChild(idSpan);
        link.appendChild(metaSpan);
        li.appendChild(link);
        fragment.appendChild(li);
      });
      list.appendChild(fragment);
    }

    function render() {
      const words = inputs.map((input) => input.value.trim().toLowerCase());
      const [w1, w2, w3] = words;

      let matches = normalized;
      if (w1 || w2 || w3) {
        matches = normalized.filter((entry) => {
          const [ew1, ew2, ew3] = entry.lowerWords;
          return (
            (!w1 || (ew1 && ew1.startsWith(w1))) &&
            (!w2 || (ew2 && ew2.startsWith(w2))) &&
            (!w3 || (ew3 && ew3.startsWith(w3)))
          );
        });
      }

      const typed = inputs
        .map((input) => input.value.trim())
        .filter(Boolean)
        .join(" ");

      const totalMatches = matches.length;
      const limited = matches.slice(0, LIMIT);
      renderMatches(limited);

      const label = totalMatches === 1 ? "part" : "parts";
      const hasTyped = typed.length > 0;
      let message;
      if (hasTyped) {
        message = `${totalMatches} ${label} match "${typed}".`;
        if (totalMatches > LIMIT) {
          message += ` Displaying first ${LIMIT}.`;
        }
      } else if (totalMatches > LIMIT) {
        message = `Displaying first ${LIMIT} of ${totalMatches} ${label}. Enter mnemonic words to narrow the list.`;
      } else {
        message = `Displaying ${totalMatches} ${label}. Enter mnemonic words to narrow the list.`;
      }
      if (!hasTyped && totalMatches === totalParts) {
        message += " Showing all available parts.";
      }
      summary.textContent = message;
    }

    function updateSuggestions(index) {
      const input = inputs[index];
      const query = input.value.trim().toLowerCase();
      const suggestionList = suggestionLists[index];
      suggestionList.textContent = "";
      activeSuggestionIndex[index] = -1;

      if (!query) {
        suggestionList.classList.remove("show");
        return;
      }

      const matches = WORDS.filter((word) => word.startsWith(query)).slice(0, 8);
      if (matches.length === 0) {
        suggestionList.classList.remove("show");
        return;
      }

      const fragment = document.createDocumentFragment();
      matches.forEach((word, suggestionIdx) => {
        const item = document.createElement("li");
        item.textContent = word;
        item.addEventListener("mousedown", (event) => {
          event.preventDefault();
          inputs[index].value = word;
          suggestionList.classList.remove("show");
          activeSuggestionIndex[index] = -1;
          render();
          const next = inputs[index + 1];
          if (next) {
            next.focus();
          }
        });
        item.addEventListener("mouseenter", () => {
          activeSuggestionIndex[index] = suggestionIdx;
          highlightSuggestion(suggestionList, activeSuggestionIndex[index]);
        });
        fragment.appendChild(item);
      });
      suggestionList.appendChild(fragment);
      suggestionList.classList.add("show");
    }

    inputs.forEach((input, index) => {
      input.addEventListener("input", () => {
        updateSuggestions(index);
        render();
      });
      input.addEventListener("change", () => {
        updateSuggestions(index);
        render();
      });
      input.addEventListener("focus", () => updateSuggestions(index));
      input.addEventListener("blur", () => {
        setTimeout(() => suggestionLists[index].classList.remove("show"), 120);
      });
      input.addEventListener("keydown", (event) => {
        const suggestionList = suggestionLists[index];

        const ensureItems = () => {
          if (!suggestionList.classList.contains("show")) {
            updateSuggestions(index);
          }
          return suggestionList.querySelectorAll("li");
        };

        if (event.key === "ArrowDown") {
          event.preventDefault();
          const items = ensureItems();
          if (!items.length) {
            return;
          }
          activeSuggestionIndex[index] = (activeSuggestionIndex[index] + 1) % items.length;
          highlightSuggestion(suggestionList, activeSuggestionIndex[index]);
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          const items = ensureItems();
          if (!items.length) {
            return;
          }
          if (activeSuggestionIndex[index] <= 0) {
            activeSuggestionIndex[index] = items.length - 1;
          } else {
            activeSuggestionIndex[index] -= 1;
          }
          highlightSuggestion(suggestionList, activeSuggestionIndex[index]);
        } else if (event.key === "Tab") {
          const items = suggestionList.querySelectorAll("li");
          if (
            suggestionList.classList.contains("show") &&
            activeSuggestionIndex[index] >= 0 &&
            activeSuggestionIndex[index] < items.length
          ) {
            const selected = items[activeSuggestionIndex[index]];
            if (selected) {
              inputs[index].value = selected.textContent;
              suggestionList.classList.remove("show");
              activeSuggestionIndex[index] = -1;
              render();
            }
          }
        }
      });
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        suggestionLists.forEach((listEl) => listEl.classList.remove("show"));
      }
    });

    render();
  })();
</script>
{% endblock %}
